const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/deflate-Bl71LgHx.js","assets/pako.esm-CPws4d4z.js","assets/lerc-DHUxLs5l.js"])))=>i.map(i=>d[i]);
function S(r){return(e,...t)=>Ze(r,e,t)}function _(r,e){return S(Oe(r,e).get)}const{apply:Ze,construct:fr,defineProperty:hr,get:ur,getOwnPropertyDescriptor:Oe,getPrototypeOf:fe,has:gr,ownKeys:Je,set:yr,setPrototypeOf:dr}=Reflect,{iterator:Y,species:xr,toStringTag:Qe,for:pr}=Symbol,We=Object,{create:he,defineProperty:et,freeze:wr,is:mr}=We,tt=Array,rt=tt.prototype,Pe=rt[Y],nt=S(Pe),Ge=ArrayBuffer,it=Ge.prototype;_(it,"byteLength");const me=typeof SharedArrayBuffer<"u"?SharedArrayBuffer:null;me&&_(me.prototype,"byteLength");const Me=fe(Uint8Array);Me.from;const b=Me.prototype;b[Y];S(b.keys);S(b.values);S(b.entries);S(b.set);S(b.reverse);S(b.fill);S(b.copyWithin);S(b.sort);S(b.slice);S(b.subarray);_(b,"buffer");_(b,"byteOffset");_(b,"length");_(b,Qe);const st=Uint8Array,Fe=Uint16Array,ue=Uint32Array,ot=Float32Array,j=fe([][Y]()),Be=S(j.next),at=S(function*(){}().next),lt=fe(j),ct=DataView.prototype,ft=S(ct.getUint16),ge=WeakMap,Ce=ge.prototype,Ue=S(Ce.get),ht=S(Ce.set),_e=new ge,ut=he(null,{next:{value:function(){const e=Ue(_e,this);return Be(e)}},[Y]:{value:function(){return this}}});function gt(r){if(r[Y]===Pe&&j.next===Be)return r;const e=he(ut);return ht(_e,e,nt(r)),e}const yt=new ge,dt=he(lt,{next:{value:function(){const e=Ue(yt,this);return at(e)},writable:!0,configurable:!0}});for(const r of Je(j))r!=="next"&&et(dt,r,Oe(j,r));const Re=new Ge(4),xt=new ot(Re),pt=new ue(Re),P=new Fe(512),G=new st(512);for(let r=0;r<256;++r){const e=r-127;e<-24?(P[r]=0,P[r|256]=32768,G[r]=24,G[r|256]=24):e<-14?(P[r]=1024>>-e-14,P[r|256]=1024>>-e-14|32768,G[r]=-e-1,G[r|256]=-e-1):e<=15?(P[r]=e+15<<10,P[r|256]=e+15<<10|32768,G[r]=13,G[r|256]=13):e<128?(P[r]=31744,P[r|256]=64512,G[r]=24,G[r|256]=24):(P[r]=31744,P[r|256]=64512,G[r]=13,G[r|256]=13)}const ye=new ue(2048);for(let r=1;r<1024;++r){let e=r<<13,t=0;for(;!(e&8388608);)e<<=1,t-=8388608;e&=-8388609,t+=947912704,ye[r]=e|t}for(let r=1024;r<2048;++r)ye[r]=939524096+(r-1024<<13);const R=new ue(64);for(let r=1;r<31;++r)R[r]=r<<23;R[31]=1199570944;R[32]=2147483648;for(let r=33;r<63;++r)R[r]=2147483648+(r-32<<23);R[63]=3347054592;const Le=new Fe(64);for(let r=1;r<64;++r)r!==32&&(Le[r]=1024);function wt(r){const e=r>>10;return pt[0]=ye[Le[e]+(r&1023)]+R[e],xt[0]}function Ne(r,e,...t){return wt(ft(r,e,...gt(t)))}function ve(r){return r&&r.__esModule&&Object.prototype.hasOwnProperty.call(r,"default")?r.default:r}var Z={exports:{}},Te;function mt(){if(Te)return Z.exports;Te=1;function r(e,t,i){const n=i&&i.debug||!1;n&&console.log("[xml-utils] getting "+t+" in "+e);const s=typeof e=="object"?e.outer:e,a=s.slice(0,s.indexOf(">")+1),o=['"',"'"];for(let l=0;l<o.length;l++){const c=o[l],f=t+"\\="+c+"([^"+c+"]*)"+c;n&&console.log("[xml-utils] pattern:",f);const d=new RegExp(f).exec(a);if(n&&console.log("[xml-utils] match:",d),d)return d[1]}}return Z.exports=r,Z.exports.default=r,Z.exports}var Tt=mt();const oe=ve(Tt);var J={exports:{}},Q={exports:{}},W={exports:{}},Ae;function At(){if(Ae)return W.exports;Ae=1;function r(e,t,i){const s=new RegExp(t).exec(e.slice(i));return s?i+s.index:-1}return W.exports=r,W.exports.default=r,W.exports}var ee={exports:{}},Ie;function It(){if(Ie)return ee.exports;Ie=1;function r(e,t,i){const s=new RegExp(t).exec(e.slice(i));return s?i+s.index+s[0].length-1:-1}return ee.exports=r,ee.exports.default=r,ee.exports}var te={exports:{}},Se;function St(){if(Se)return te.exports;Se=1;function r(e,t){const i=new RegExp(t,"g"),n=e.match(i);return n?n.length:0}return te.exports=r,te.exports.default=r,te.exports}var De;function Dt(){if(De)return Q.exports;De=1;const r=At(),e=It(),t=St();function i(n,s,a){const o=a&&a.debug||!1,l=!(a&&typeof a.nested===!1),c=a&&a.startIndex||0;o&&console.log("[xml-utils] starting findTagByName with",s," and ",a);const f=r(n,`<${s}[ 
>/]`,c);if(o&&console.log("[xml-utils] start:",f),f===-1)return;const h=n.slice(f+s.length);let d=e(h,"^[^<]*[ /]>",0);const u=d!==-1&&h[d-1]==="/";if(o&&console.log("[xml-utils] selfClosing:",u),u===!1)if(l){let m=0,p=1,T=0;for(;(d=e(h,"[ /]"+s+">",m))!==-1;){const A=h.substring(m,d+1);if(p+=t(A,"<"+s+`[ 
	>]`),T+=t(A,"</"+s+">"),T>=p)break;m=d}}else d=e(h,"[ /]"+s+">",0);const g=f+s.length+d+1;if(o&&console.log("[xml-utils] end:",g),g===-1)return;const x=n.slice(f,g);let y;return u?y=null:y=x.slice(x.indexOf(">")+1,x.lastIndexOf("<")),{inner:y,outer:x,start:f,end:g}}return Q.exports=i,Q.exports.default=i,Q.exports}var be;function bt(){if(be)return J.exports;be=1;const r=Dt();function e(t,i,n){const s=[],a=n&&n.debug||!1,o=n&&typeof n.nested=="boolean"?n.nested:!0;let l=n&&n.startIndex||0,c;for(;c=r(t,i,{debug:a,startIndex:l});)o?l=c.start+1+i.length:l=c.end,s.push(c);return a&&console.log("findTagsByName found",s.length,"tags"),s}return J.exports=e,J.exports.default=e,J.exports}var Et=bt();const Ot=ve(Et),k={315:"Artist",258:"BitsPerSample",265:"CellLength",264:"CellWidth",320:"ColorMap",259:"Compression",33432:"Copyright",306:"DateTime",338:"ExtraSamples",266:"FillOrder",289:"FreeByteCounts",288:"FreeOffsets",291:"GrayResponseCurve",290:"GrayResponseUnit",316:"HostComputer",270:"ImageDescription",257:"ImageLength",256:"ImageWidth",271:"Make",281:"MaxSampleValue",280:"MinSampleValue",272:"Model",254:"NewSubfileType",274:"Orientation",262:"PhotometricInterpretation",284:"PlanarConfiguration",296:"ResolutionUnit",278:"RowsPerStrip",277:"SamplesPerPixel",305:"Software",279:"StripByteCounts",273:"StripOffsets",255:"SubfileType",263:"Threshholding",282:"XResolution",283:"YResolution",326:"BadFaxLines",327:"CleanFaxData",343:"ClipPath",328:"ConsecutiveBadFaxLines",433:"Decode",434:"DefaultImageColor",269:"DocumentName",336:"DotRange",321:"HalftoneHints",346:"Indexed",347:"JPEGTables",285:"PageName",297:"PageNumber",317:"Predictor",319:"PrimaryChromaticities",532:"ReferenceBlackWhite",339:"SampleFormat",340:"SMinSampleValue",341:"SMaxSampleValue",559:"StripRowCounts",330:"SubIFDs",292:"T4Options",293:"T6Options",325:"TileByteCounts",323:"TileLength",324:"TileOffsets",322:"TileWidth",301:"TransferFunction",318:"WhitePoint",344:"XClipPathUnits",286:"XPosition",529:"YCbCrCoefficients",531:"YCbCrPositioning",530:"YCbCrSubSampling",345:"YClipPathUnits",287:"YPosition",37378:"ApertureValue",40961:"ColorSpace",36868:"DateTimeDigitized",36867:"DateTimeOriginal",34665:"Exif IFD",36864:"ExifVersion",33434:"ExposureTime",41728:"FileSource",37385:"Flash",40960:"FlashpixVersion",33437:"FNumber",42016:"ImageUniqueID",37384:"LightSource",37500:"MakerNote",37377:"ShutterSpeedValue",37510:"UserComment",33723:"IPTC",34675:"ICC Profile",700:"XMP",42112:"GDAL_METADATA",42113:"GDAL_NODATA",34377:"Photoshop",33550:"ModelPixelScale",33922:"ModelTiepoint",34264:"ModelTransformation",34735:"GeoKeyDirectory",34736:"GeoDoubleParams",34737:"GeoAsciiParams",50674:"LercParameters"},M={};for(const r in k)k.hasOwnProperty(r)&&(M[k[r]]=parseInt(r,10));const Pt=[M.BitsPerSample,M.ExtraSamples,M.SampleFormat,M.StripByteCounts,M.StripOffsets,M.StripRowCounts,M.TileByteCounts,M.TileOffsets,M.SubIFDs],ae={1:"BYTE",2:"ASCII",3:"SHORT",4:"LONG",5:"RATIONAL",6:"SBYTE",7:"UNDEFINED",8:"SSHORT",9:"SLONG",10:"SRATIONAL",11:"FLOAT",12:"DOUBLE",13:"IFD",16:"LONG8",17:"SLONG8",18:"IFD8"},w={};for(const r in ae)ae.hasOwnProperty(r)&&(w[ae[r]]=parseInt(r,10));const O={WhiteIsZero:0,BlackIsZero:1,RGB:2,Palette:3,TransparencyMask:4,CMYK:5,YCbCr:6,CIELab:8,ICCLab:9},Gt={Unspecified:0,Assocalpha:1,Unassalpha:2},Tr={Version:0,AddCompression:1},Ar={None:0,Deflate:1,Zstandard:2},Mt={1024:"GTModelTypeGeoKey",1025:"GTRasterTypeGeoKey",1026:"GTCitationGeoKey",2048:"GeographicTypeGeoKey",2049:"GeogCitationGeoKey",2050:"GeogGeodeticDatumGeoKey",2051:"GeogPrimeMeridianGeoKey",2052:"GeogLinearUnitsGeoKey",2053:"GeogLinearUnitSizeGeoKey",2054:"GeogAngularUnitsGeoKey",2055:"GeogAngularUnitSizeGeoKey",2056:"GeogEllipsoidGeoKey",2057:"GeogSemiMajorAxisGeoKey",2058:"GeogSemiMinorAxisGeoKey",2059:"GeogInvFlatteningGeoKey",2060:"GeogAzimuthUnitsGeoKey",2061:"GeogPrimeMeridianLongGeoKey",2062:"GeogTOWGS84GeoKey",3072:"ProjectedCSTypeGeoKey",3073:"PCSCitationGeoKey",3074:"ProjectionGeoKey",3075:"ProjCoordTransGeoKey",3076:"ProjLinearUnitsGeoKey",3077:"ProjLinearUnitSizeGeoKey",3078:"ProjStdParallel1GeoKey",3079:"ProjStdParallel2GeoKey",3080:"ProjNatOriginLongGeoKey",3081:"ProjNatOriginLatGeoKey",3082:"ProjFalseEastingGeoKey",3083:"ProjFalseNorthingGeoKey",3084:"ProjFalseOriginLongGeoKey",3085:"ProjFalseOriginLatGeoKey",3086:"ProjFalseOriginEastingGeoKey",3087:"ProjFalseOriginNorthingGeoKey",3088:"ProjCenterLongGeoKey",3089:"ProjCenterLatGeoKey",3090:"ProjCenterEastingGeoKey",3091:"ProjCenterNorthingGeoKey",3092:"ProjScaleAtNatOriginGeoKey",3093:"ProjScaleAtCenterGeoKey",3094:"ProjAzimuthAngleGeoKey",3095:"ProjStraightVertPoleLongGeoKey",3096:"ProjRectifiedGridAngleGeoKey",4096:"VerticalCSTypeGeoKey",4097:"VerticalCitationGeoKey",4098:"VerticalDatumGeoKey",4099:"VerticalUnitsGeoKey"};function Ft(r,e){const{width:t,height:i}=r,n=new Uint8Array(t*i*3);let s;for(let a=0,o=0;a<r.length;++a,o+=3)s=256-r[a]/e*256,n[o]=s,n[o+1]=s,n[o+2]=s;return n}function Bt(r,e){const{width:t,height:i}=r,n=new Uint8Array(t*i*3);let s;for(let a=0,o=0;a<r.length;++a,o+=3)s=r[a]/e*256,n[o]=s,n[o+1]=s,n[o+2]=s;return n}function Ct(r,e){const{width:t,height:i}=r,n=new Uint8Array(t*i*3),s=e.length/3,a=e.length/3*2;for(let o=0,l=0;o<r.length;++o,l+=3){const c=r[o];n[l]=e[c]/65536*256,n[l+1]=e[c+s]/65536*256,n[l+2]=e[c+a]/65536*256}return n}function Ut(r){const{width:e,height:t}=r,i=new Uint8Array(e*t*3);for(let n=0,s=0;n<r.length;n+=4,s+=3){const a=r[n],o=r[n+1],l=r[n+2],c=r[n+3];i[s]=255*((255-a)/256)*((255-c)/256),i[s+1]=255*((255-o)/256)*((255-c)/256),i[s+2]=255*((255-l)/256)*((255-c)/256)}return i}function _t(r){const{width:e,height:t}=r,i=new Uint8ClampedArray(e*t*3);for(let n=0,s=0;n<r.length;n+=3,s+=3){const a=r[n],o=r[n+1],l=r[n+2];i[s]=a+1.402*(l-128),i[s+1]=a-.34414*(o-128)-.71414*(l-128),i[s+2]=a+1.772*(o-128)}return i}const Rt=.95047,Lt=1,Nt=1.08883;function vt(r){const{width:e,height:t}=r,i=new Uint8Array(e*t*3);for(let n=0,s=0;n<r.length;n+=3,s+=3){const a=r[n+0],o=r[n+1]<<24>>24,l=r[n+2]<<24>>24;let c=(a+16)/116,f=o/500+c,h=c-l/200,d,u,g;f=Rt*(f*f*f>.008856?f*f*f:(f-16/116)/7.787),c=Lt*(c*c*c>.008856?c*c*c:(c-16/116)/7.787),h=Nt*(h*h*h>.008856?h*h*h:(h-16/116)/7.787),d=f*3.2406+c*-1.5372+h*-.4986,u=f*-.9689+c*1.8758+h*.0415,g=f*.0557+c*-.204+h*1.057,d=d>.0031308?1.055*d**(1/2.4)-.055:12.92*d,u=u>.0031308?1.055*u**(1/2.4)-.055:12.92*u,g=g>.0031308?1.055*g**(1/2.4)-.055:12.92*g,i[s]=Math.max(0,Math.min(1,d))*255,i[s+1]=Math.max(0,Math.min(1,u))*255,i[s+2]=Math.max(0,Math.min(1,g))*255}return i}const Vt="modulepreload",Kt=function(r){return"/3dsub/"+r},Ee={},B=function(e,t,i){let n=Promise.resolve();if(t&&t.length>0){document.getElementsByTagName("link");const a=document.querySelector("meta[property=csp-nonce]"),o=(a==null?void 0:a.nonce)||(a==null?void 0:a.getAttribute("nonce"));n=Promise.allSettled(t.map(l=>{if(l=Kt(l),l in Ee)return;Ee[l]=!0;const c=l.endsWith(".css"),f=c?'[rel="stylesheet"]':"";if(document.querySelector(`link[href="${l}"]${f}`))return;const h=document.createElement("link");if(h.rel=c?"stylesheet":Vt,c||(h.as="script"),h.crossOrigin="",h.href=l,o&&h.setAttribute("nonce",o),document.head.appendChild(h),c)return new Promise((d,u)=>{h.addEventListener("load",d),h.addEventListener("error",()=>u(new Error(`Unable to preload CSS for ${l}`)))})}))}function s(a){const o=new Event("vite:preloadError",{cancelable:!0});if(o.payload=a,window.dispatchEvent(o),!o.defaultPrevented)throw a}return n.then(a=>{for(const o of a||[])o.status==="rejected"&&s(o.reason);return e().catch(s)})},Ve=new Map;function F(r,e){Array.isArray(r)||(r=[r]),r.forEach(t=>Ve.set(t,e))}async function kt(r){const e=Ve.get(r.Compression);if(!e)throw new Error(`Unknown compression method identifier: ${r.Compression}`);const t=await e();return new t(r)}F([void 0,1],()=>B(()=>import("./raw-WpTpH2pL.js"),[]).then(r=>r.default));F(5,()=>B(()=>import("./lzw-DhYzv8gL.js"),[]).then(r=>r.default));F(6,()=>{throw new Error("old style JPEG compression is not supported.")});F(7,()=>B(()=>import("./jpeg-BvOT2CEd.js"),[]).then(r=>r.default));F([8,32946],()=>B(()=>import("./deflate-Bl71LgHx.js"),__vite__mapDeps([0,1])).then(r=>r.default));F(32773,()=>B(()=>import("./packbits-DdLO9FS-.js"),[]).then(r=>r.default));F(34887,()=>B(()=>import("./lerc-DHUxLs5l.js"),__vite__mapDeps([2,1])).then(async r=>(await r.zstd.init(),r)).then(r=>r.default));F(50001,()=>B(()=>import("./webimage-C9c-P38n.js"),[]).then(r=>r.default));function ne(r,e,t,i=1){return new(Object.getPrototypeOf(r)).constructor(e*t*i)}function jt(r,e,t,i,n){const s=e/i,a=t/n;return r.map(o=>{const l=ne(o,i,n);for(let c=0;c<n;++c){const f=Math.min(Math.round(a*c),t-1);for(let h=0;h<i;++h){const d=Math.min(Math.round(s*h),e-1),u=o[f*e+d];l[c*i+h]=u}}return l})}function U(r,e,t){return(1-t)*r+t*e}function Yt(r,e,t,i,n){const s=e/i,a=t/n;return r.map(o=>{const l=ne(o,i,n);for(let c=0;c<n;++c){const f=a*c,h=Math.floor(f),d=Math.min(Math.ceil(f),t-1);for(let u=0;u<i;++u){const g=s*u,x=g%1,y=Math.floor(g),m=Math.min(Math.ceil(g),e-1),p=o[h*e+y],T=o[h*e+m],A=o[d*e+y],I=o[d*e+m],E=U(U(p,T,x),U(A,I,x),f%1);l[c*i+u]=E}}return l})}function qt(r,e,t,i,n,s="nearest"){switch(s.toLowerCase()){case"nearest":return jt(r,e,t,i,n);case"bilinear":case"linear":return Yt(r,e,t,i,n);default:throw new Error(`Unsupported resampling method: '${s}'`)}}function Xt(r,e,t,i,n,s){const a=e/i,o=t/n,l=ne(r,i,n,s);for(let c=0;c<n;++c){const f=Math.min(Math.round(o*c),t-1);for(let h=0;h<i;++h){const d=Math.min(Math.round(a*h),e-1);for(let u=0;u<s;++u){const g=r[f*e*s+d*s+u];l[c*i*s+h*s+u]=g}}}return l}function $t(r,e,t,i,n,s){const a=e/i,o=t/n,l=ne(r,i,n,s);for(let c=0;c<n;++c){const f=o*c,h=Math.floor(f),d=Math.min(Math.ceil(f),t-1);for(let u=0;u<i;++u){const g=a*u,x=g%1,y=Math.floor(g),m=Math.min(Math.ceil(g),e-1);for(let p=0;p<s;++p){const T=r[h*e*s+y*s+p],A=r[h*e*s+m*s+p],I=r[d*e*s+y*s+p],E=r[d*e*s+m*s+p],L=U(U(T,A,x),U(I,E,x),f%1);l[c*i*s+u*s+p]=L}}}return l}function zt(r,e,t,i,n,s,a="nearest"){switch(a.toLowerCase()){case"nearest":return Xt(r,e,t,i,n,s);case"bilinear":case"linear":return $t(r,e,t,i,n,s);default:throw new Error(`Unsupported resampling method: '${a}'`)}}function Ht(r,e,t){let i=0;for(let n=e;n<t;++n)i+=r[n];return i}function le(r,e,t){switch(r){case 1:if(e<=8)return new Uint8Array(t);if(e<=16)return new Uint16Array(t);if(e<=32)return new Uint32Array(t);break;case 2:if(e===8)return new Int8Array(t);if(e===16)return new Int16Array(t);if(e===32)return new Int32Array(t);break;case 3:switch(e){case 16:case 32:return new Float32Array(t);case 64:return new Float64Array(t)}break}throw Error("Unsupported data format/bitsPerSample")}function Zt(r,e){return(r===1||r===2)&&e<=32&&e%8===0?!1:!(r===3&&(e===16||e===32||e===64))}function Jt(r,e,t,i,n,s,a){const o=new DataView(r),l=t===2?a*s:a*s*i,c=t===2?1:i,f=le(e,n,l),h=parseInt("1".repeat(n),2);if(e===1){let d;t===1?d=i*n:d=n;let u=s*d;u&7&&(u=u+7&-8);for(let g=0;g<a;++g){const x=g*u;for(let y=0;y<s;++y){const m=x+y*c*n;for(let p=0;p<c;++p){const T=m+p*n,A=(g*s+y)*c+p,I=Math.floor(T/8),E=T%8;if(E+n<=8)f[A]=o.getUint8(I)>>8-n-E&h;else if(E+n<=16)f[A]=o.getUint16(I)>>16-n-E&h;else if(E+n<=24){const L=o.getUint16(I)<<8|o.getUint8(I+2);f[A]=L>>24-n-E&h}else f[A]=o.getUint32(I)>>32-n-E&h}}}}return f.buffer}class Qt{constructor(e,t,i,n,s,a){this.fileDirectory=e,this.geoKeys=t,this.dataView=i,this.littleEndian=n,this.tiles=s?{}:null,this.isTiled=!e.StripOffsets;const o=e.PlanarConfiguration;if(this.planarConfiguration=typeof o>"u"?1:o,this.planarConfiguration!==1&&this.planarConfiguration!==2)throw new Error("Invalid planar configuration.");this.source=a}getFileDirectory(){return this.fileDirectory}getGeoKeys(){return this.geoKeys}getWidth(){return this.fileDirectory.ImageWidth}getHeight(){return this.fileDirectory.ImageLength}getSamplesPerPixel(){return typeof this.fileDirectory.SamplesPerPixel<"u"?this.fileDirectory.SamplesPerPixel:1}getTileWidth(){return this.isTiled?this.fileDirectory.TileWidth:this.getWidth()}getTileHeight(){return this.isTiled?this.fileDirectory.TileLength:typeof this.fileDirectory.RowsPerStrip<"u"?Math.min(this.fileDirectory.RowsPerStrip,this.getHeight()):this.getHeight()}getBlockWidth(){return this.getTileWidth()}getBlockHeight(e){return this.isTiled||(e+1)*this.getTileHeight()<=this.getHeight()?this.getTileHeight():this.getHeight()-e*this.getTileHeight()}getBytesPerPixel(){let e=0;for(let t=0;t<this.fileDirectory.BitsPerSample.length;++t)e+=this.getSampleByteSize(t);return e}getSampleByteSize(e){if(e>=this.fileDirectory.BitsPerSample.length)throw new RangeError(`Sample index ${e} is out of range.`);return Math.ceil(this.fileDirectory.BitsPerSample[e]/8)}getReaderForSample(e){const t=this.fileDirectory.SampleFormat?this.fileDirectory.SampleFormat[e]:1,i=this.fileDirectory.BitsPerSample[e];switch(t){case 1:if(i<=8)return DataView.prototype.getUint8;if(i<=16)return DataView.prototype.getUint16;if(i<=32)return DataView.prototype.getUint32;break;case 2:if(i<=8)return DataView.prototype.getInt8;if(i<=16)return DataView.prototype.getInt16;if(i<=32)return DataView.prototype.getInt32;break;case 3:switch(i){case 16:return function(n,s){return Ne(this,n,s)};case 32:return DataView.prototype.getFloat32;case 64:return DataView.prototype.getFloat64}break}throw Error("Unsupported data format/bitsPerSample")}getSampleFormat(e=0){return this.fileDirectory.SampleFormat?this.fileDirectory.SampleFormat[e]:1}getBitsPerSample(e=0){return this.fileDirectory.BitsPerSample[e]}getArrayForSample(e,t){const i=this.getSampleFormat(e),n=this.getBitsPerSample(e);return le(i,n,t)}async getTileOrStrip(e,t,i,n,s){const a=Math.ceil(this.getWidth()/this.getTileWidth()),o=Math.ceil(this.getHeight()/this.getTileHeight());let l;const{tiles:c}=this;this.planarConfiguration===1?l=t*a+e:this.planarConfiguration===2&&(l=i*a*o+t*a+e);let f,h;this.isTiled?(f=this.fileDirectory.TileOffsets[l],h=this.fileDirectory.TileByteCounts[l]):(f=this.fileDirectory.StripOffsets[l],h=this.fileDirectory.StripByteCounts[l]);const d=(await this.source.fetch([{offset:f,length:h}],s))[0];let u;return c===null||!c[l]?(u=(async()=>{let g=await n.decode(this.fileDirectory,d);const x=this.getSampleFormat(),y=this.getBitsPerSample();return Zt(x,y)&&(g=Jt(g,x,this.planarConfiguration,this.getSamplesPerPixel(),y,this.getTileWidth(),this.getBlockHeight(t))),g})(),c!==null&&(c[l]=u)):u=c[l],{x:e,y:t,sample:i,data:await u}}async _readRaster(e,t,i,n,s,a,o,l,c){const f=this.getTileWidth(),h=this.getTileHeight(),d=this.getWidth(),u=this.getHeight(),g=Math.max(Math.floor(e[0]/f),0),x=Math.min(Math.ceil(e[2]/f),Math.ceil(d/f)),y=Math.max(Math.floor(e[1]/h),0),m=Math.min(Math.ceil(e[3]/h),Math.ceil(u/h)),p=e[2]-e[0];let T=this.getBytesPerPixel();const A=[],I=[];for(let D=0;D<t.length;++D)this.planarConfiguration===1?A.push(Ht(this.fileDirectory.BitsPerSample,0,t[D])/8):A.push(0),I.push(this.getReaderForSample(t[D]));const E=[],{littleEndian:L}=this;for(let D=y;D<m;++D)for(let q=g;q<x;++q){let ie;this.planarConfiguration===1&&(ie=this.getTileOrStrip(q,D,0,s,c));for(let X=0;X<t.length;++X){const $=X,pe=t[X];this.planarConfiguration===2&&(T=this.getSampleByteSize(pe),ie=this.getTileOrStrip(q,D,pe,s,c));const Ke=ie.then(N=>{const ke=N.data,je=new DataView(ke),se=this.getBlockHeight(N.y),v=N.y*h,z=N.x*f,Ye=v+se,qe=(N.x+1)*f,Xe=I[$],$e=Math.min(se,se-(Ye-e[3]),u-v),ze=Math.min(f,f-(qe-e[2]),d-z);for(let V=Math.max(0,e[1]-v);V<$e;++V)for(let K=Math.max(0,e[0]-z);K<ze;++K){const He=(V*f+K)*T,we=Xe.call(je,He+A[$],L);let H;n?(H=(V+v-e[1])*p*t.length+(K+z-e[0])*t.length+$,i[H]=we):(H=(V+v-e[1])*p+K+z-e[0],i[$][H]=we)}});E.push(Ke)}}if(await Promise.all(E),a&&e[2]-e[0]!==a||o&&e[3]-e[1]!==o){let D;return n?D=zt(i,e[2]-e[0],e[3]-e[1],a,o,t.length,l):D=qt(i,e[2]-e[0],e[3]-e[1],a,o,l),D.width=a,D.height=o,D}return i.width=a||e[2]-e[0],i.height=o||e[3]-e[1],i}async readRasters({window:e,samples:t=[],interleave:i,pool:n=null,width:s,height:a,resampleMethod:o,fillValue:l,signal:c}={}){const f=e||[0,0,this.getWidth(),this.getHeight()];if(f[0]>f[2]||f[1]>f[3])throw new Error("Invalid subsets");const h=f[2]-f[0],d=f[3]-f[1],u=h*d,g=this.getSamplesPerPixel();if(!t||!t.length)for(let p=0;p<g;++p)t.push(p);else for(let p=0;p<t.length;++p)if(t[p]>=g)return Promise.reject(new RangeError(`Invalid sample index '${t[p]}'.`));let x;if(i){const p=this.fileDirectory.SampleFormat?Math.max.apply(null,this.fileDirectory.SampleFormat):1,T=Math.max.apply(null,this.fileDirectory.BitsPerSample);x=le(p,T,u*t.length),l&&x.fill(l)}else{x=[];for(let p=0;p<t.length;++p){const T=this.getArrayForSample(t[p],u);Array.isArray(l)&&p<l.length?T.fill(l[p]):l&&!Array.isArray(l)&&T.fill(l),x.push(T)}}const y=n||await kt(this.fileDirectory);return await this._readRaster(f,t,x,i,y,s,a,o,c)}async readRGB({window:e,interleave:t=!0,pool:i=null,width:n,height:s,resampleMethod:a,enableAlpha:o=!1,signal:l}={}){const c=e||[0,0,this.getWidth(),this.getHeight()];if(c[0]>c[2]||c[1]>c[3])throw new Error("Invalid subsets");const f=this.fileDirectory.PhotometricInterpretation;if(f===O.RGB){let m=[0,1,2];if(this.fileDirectory.ExtraSamples!==Gt.Unspecified&&o){m=[];for(let p=0;p<this.fileDirectory.BitsPerSample.length;p+=1)m.push(p)}return this.readRasters({window:e,interleave:t,samples:m,pool:i,width:n,height:s,resampleMethod:a,signal:l})}let h;switch(f){case O.WhiteIsZero:case O.BlackIsZero:case O.Palette:h=[0];break;case O.CMYK:h=[0,1,2,3];break;case O.YCbCr:case O.CIELab:h=[0,1,2];break;default:throw new Error("Invalid or unsupported photometric interpretation.")}const d={window:c,interleave:!0,samples:h,pool:i,width:n,height:s,resampleMethod:a,signal:l},{fileDirectory:u}=this,g=await this.readRasters(d),x=2**this.fileDirectory.BitsPerSample[0];let y;switch(f){case O.WhiteIsZero:y=Ft(g,x);break;case O.BlackIsZero:y=Bt(g,x);break;case O.Palette:y=Ct(g,u.ColorMap);break;case O.CMYK:y=Ut(g);break;case O.YCbCr:y=_t(g);break;case O.CIELab:y=vt(g);break;default:throw new Error("Unsupported photometric interpretation.")}if(!t){const m=new Uint8Array(y.length/3),p=new Uint8Array(y.length/3),T=new Uint8Array(y.length/3);for(let A=0,I=0;A<y.length;A+=3,++I)m[I]=y[A],p[I]=y[A+1],T[I]=y[A+2];y=[m,p,T]}return y.width=g.width,y.height=g.height,y}getTiePoints(){if(!this.fileDirectory.ModelTiepoint)return[];const e=[];for(let t=0;t<this.fileDirectory.ModelTiepoint.length;t+=6)e.push({i:this.fileDirectory.ModelTiepoint[t],j:this.fileDirectory.ModelTiepoint[t+1],k:this.fileDirectory.ModelTiepoint[t+2],x:this.fileDirectory.ModelTiepoint[t+3],y:this.fileDirectory.ModelTiepoint[t+4],z:this.fileDirectory.ModelTiepoint[t+5]});return e}getGDALMetadata(e=null){const t={};if(!this.fileDirectory.GDAL_METADATA)return null;const i=this.fileDirectory.GDAL_METADATA;let n=Ot(i,"Item");e===null?n=n.filter(s=>oe(s,"sample")===void 0):n=n.filter(s=>Number(oe(s,"sample"))===e);for(let s=0;s<n.length;++s){const a=n[s];t[oe(a,"name")]=a.inner}return t}getGDALNoData(){if(!this.fileDirectory.GDAL_NODATA)return null;const e=this.fileDirectory.GDAL_NODATA;return Number(e.substring(0,e.length-1))}getOrigin(){const e=this.fileDirectory.ModelTiepoint,t=this.fileDirectory.ModelTransformation;if(e&&e.length===6)return[e[3],e[4],e[5]];if(t)return[t[3],t[7],t[11]];throw new Error("The image does not have an affine transformation.")}getResolution(e=null){const t=this.fileDirectory.ModelPixelScale,i=this.fileDirectory.ModelTransformation;if(t)return[t[0],-t[1],t[2]];if(i)return i[1]===0&&i[4]===0?[i[0],-i[5],i[10]]:[Math.sqrt(i[0]*i[0]+i[4]*i[4]),-Math.sqrt(i[1]*i[1]+i[5]*i[5]),i[10]];if(e){const[n,s,a]=e.getResolution();return[n*e.getWidth()/this.getWidth(),s*e.getHeight()/this.getHeight(),a*e.getWidth()/this.getWidth()]}throw new Error("The image does not have an affine transformation.")}pixelIsArea(){return this.geoKeys.GTRasterTypeGeoKey===1}getBoundingBox(e=!1){const t=this.getHeight(),i=this.getWidth();if(this.fileDirectory.ModelTransformation&&!e){const[n,s,a,o,l,c,f,h]=this.fileDirectory.ModelTransformation,u=[[0,0],[0,t],[i,0],[i,t]].map(([y,m])=>[o+n*y+s*m,h+l*y+c*m]),g=u.map(y=>y[0]),x=u.map(y=>y[1]);return[Math.min(...g),Math.min(...x),Math.max(...g),Math.max(...x)]}else{const n=this.getOrigin(),s=this.getResolution(),a=n[0],o=n[1],l=a+s[0]*i,c=o+s[1]*t;return[Math.min(a,l),Math.min(o,c),Math.max(a,l),Math.max(o,c)]}}}class Wt{constructor(e){this._dataView=new DataView(e)}get buffer(){return this._dataView.buffer}getUint64(e,t){const i=this.getUint32(e,t),n=this.getUint32(e+4,t);let s;if(t){if(s=i+2**32*n,!Number.isSafeInteger(s))throw new Error(`${s} exceeds MAX_SAFE_INTEGER. Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues`);return s}if(s=2**32*i+n,!Number.isSafeInteger(s))throw new Error(`${s} exceeds MAX_SAFE_INTEGER. Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues`);return s}getInt64(e,t){let i=0;const n=(this._dataView.getUint8(e+(t?7:0))&128)>0;let s=!0;for(let a=0;a<8;a++){let o=this._dataView.getUint8(e+(t?a:7-a));n&&(s?o!==0&&(o=~(o-1)&255,s=!1):o=~o&255),i+=o*256**a}return n&&(i=-i),i}getUint8(e,t){return this._dataView.getUint8(e,t)}getInt8(e,t){return this._dataView.getInt8(e,t)}getUint16(e,t){return this._dataView.getUint16(e,t)}getInt16(e,t){return this._dataView.getInt16(e,t)}getUint32(e,t){return this._dataView.getUint32(e,t)}getInt32(e,t){return this._dataView.getInt32(e,t)}getFloat16(e,t){return Ne(this._dataView,e,t)}getFloat32(e,t){return this._dataView.getFloat32(e,t)}getFloat64(e,t){return this._dataView.getFloat64(e,t)}}class er{constructor(e,t,i,n){this._dataView=new DataView(e),this._sliceOffset=t,this._littleEndian=i,this._bigTiff=n}get sliceOffset(){return this._sliceOffset}get sliceTop(){return this._sliceOffset+this.buffer.byteLength}get littleEndian(){return this._littleEndian}get bigTiff(){return this._bigTiff}get buffer(){return this._dataView.buffer}covers(e,t){return this.sliceOffset<=e&&this.sliceTop>=e+t}readUint8(e){return this._dataView.getUint8(e-this._sliceOffset,this._littleEndian)}readInt8(e){return this._dataView.getInt8(e-this._sliceOffset,this._littleEndian)}readUint16(e){return this._dataView.getUint16(e-this._sliceOffset,this._littleEndian)}readInt16(e){return this._dataView.getInt16(e-this._sliceOffset,this._littleEndian)}readUint32(e){return this._dataView.getUint32(e-this._sliceOffset,this._littleEndian)}readInt32(e){return this._dataView.getInt32(e-this._sliceOffset,this._littleEndian)}readFloat32(e){return this._dataView.getFloat32(e-this._sliceOffset,this._littleEndian)}readFloat64(e){return this._dataView.getFloat64(e-this._sliceOffset,this._littleEndian)}readUint64(e){const t=this.readUint32(e),i=this.readUint32(e+4);let n;if(this._littleEndian){if(n=t+2**32*i,!Number.isSafeInteger(n))throw new Error(`${n} exceeds MAX_SAFE_INTEGER. Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues`);return n}if(n=2**32*t+i,!Number.isSafeInteger(n))throw new Error(`${n} exceeds MAX_SAFE_INTEGER. Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues`);return n}readInt64(e){let t=0;const i=(this._dataView.getUint8(e+(this._littleEndian?7:0))&128)>0;let n=!0;for(let s=0;s<8;s++){let a=this._dataView.getUint8(e+(this._littleEndian?s:7-s));i&&(n?a!==0&&(a=~(a-1)&255,n=!1):a=~a&255),t+=a*256**s}return i&&(t=-t),t}readOffset(e){return this._bigTiff?this.readUint64(e):this.readUint32(e)}}class tr{async fetch(e,t=void 0){return Promise.all(e.map(i=>this.fetchSlice(i,t)))}async fetchSlice(e){throw new Error(`fetching of slice ${e} not possible, not implemented`)}get fileSize(){return null}async close(){}}class de extends Error{constructor(e){super(e),Error.captureStackTrace&&Error.captureStackTrace(this,de),this.name="AbortError"}}class rr extends tr{constructor(e){super(),this.arrayBuffer=e}fetchSlice(e,t){if(t&&t.aborted)throw new de("Request aborted");return this.arrayBuffer.slice(e.offset,e.offset+e.length)}}function nr(r){return new rr(r)}function ir(r,e){let t=r.length-e,i=0;do{for(let n=e;n>0;n--)r[i+e]+=r[i],i++;t-=e}while(t>0)}function sr(r,e,t){let i=0,n=r.length;const s=n/t;for(;n>e;){for(let o=e;o>0;--o)r[i+e]+=r[i],++i;n-=e}const a=r.slice();for(let o=0;o<s;++o)for(let l=0;l<t;++l)r[t*o+l]=a[(t-l-1)*s+o]}function or(r,e,t,i,n,s){if(!e||e===1)return r;for(let l=0;l<n.length;++l){if(n[l]%8!==0)throw new Error("When decoding with predictor, only multiple of 8 bits are supported.");if(n[l]!==n[0])throw new Error("When decoding with predictor, all samples must have the same size.")}const a=n[0]/8,o=s===2?1:n.length;for(let l=0;l<i&&!(l*o*t*a>=r.byteLength);++l){let c;if(e===2){switch(n[0]){case 8:c=new Uint8Array(r,l*o*t*a,o*t*a);break;case 16:c=new Uint16Array(r,l*o*t*a,o*t*a/2);break;case 32:c=new Uint32Array(r,l*o*t*a,o*t*a/4);break;default:throw new Error(`Predictor 2 not allowed with ${n[0]} bits per sample.`)}ir(c,o)}else e===3&&(c=new Uint8Array(r,l*o*t*a,o*t*a),sr(c,o,a))}return r}class Ir{async decode(e,t){const i=await this.decodeBlock(t),n=e.Predictor||1;if(n!==1){const s=!e.StripOffsets,a=s?e.TileWidth:e.ImageWidth,o=s?e.TileLength:e.RowsPerStrip||e.ImageLength;return or(i,n,a,o,e.BitsPerSample,e.PlanarConfiguration)}return i}}function ce(r){switch(r){case w.BYTE:case w.ASCII:case w.SBYTE:case w.UNDEFINED:return 1;case w.SHORT:case w.SSHORT:return 2;case w.LONG:case w.SLONG:case w.FLOAT:case w.IFD:return 4;case w.RATIONAL:case w.SRATIONAL:case w.DOUBLE:case w.LONG8:case w.SLONG8:case w.IFD8:return 8;default:throw new RangeError(`Invalid field type: ${r}`)}}function ar(r){const e=r.GeoKeyDirectory;if(!e)return null;const t={};for(let i=4;i<=e[3]*4;i+=4){const n=Mt[e[i]],s=e[i+1]?k[e[i+1]]:null,a=e[i+2],o=e[i+3];let l=null;if(!s)l=o;else{if(l=r[s],typeof l>"u"||l===null)throw new Error(`Could not get value of geoKey '${n}'.`);typeof l=="string"?l=l.substring(o,o+a-1):l.subarray&&(l=l.subarray(o,o+a),a===1&&(l=l[0]))}t[n]=l}return t}function C(r,e,t,i){let n=null,s=null;const a=ce(e);switch(e){case w.BYTE:case w.ASCII:case w.UNDEFINED:n=new Uint8Array(t),s=r.readUint8;break;case w.SBYTE:n=new Int8Array(t),s=r.readInt8;break;case w.SHORT:n=new Uint16Array(t),s=r.readUint16;break;case w.SSHORT:n=new Int16Array(t),s=r.readInt16;break;case w.LONG:case w.IFD:n=new Uint32Array(t),s=r.readUint32;break;case w.SLONG:n=new Int32Array(t),s=r.readInt32;break;case w.LONG8:case w.IFD8:n=new Array(t),s=r.readUint64;break;case w.SLONG8:n=new Array(t),s=r.readInt64;break;case w.RATIONAL:n=new Uint32Array(t*2),s=r.readUint32;break;case w.SRATIONAL:n=new Int32Array(t*2),s=r.readInt32;break;case w.FLOAT:n=new Float32Array(t),s=r.readFloat32;break;case w.DOUBLE:n=new Float64Array(t),s=r.readFloat64;break;default:throw new RangeError(`Invalid field type: ${e}`)}if(e===w.RATIONAL||e===w.SRATIONAL)for(let o=0;o<t;o+=2)n[o]=s.call(r,i+o*a),n[o+1]=s.call(r,i+(o*a+4));else for(let o=0;o<t;++o)n[o]=s.call(r,i+o*a);return e===w.ASCII?new TextDecoder("utf-8").decode(n):n}class lr{constructor(e,t,i){this.fileDirectory=e,this.geoKeyDirectory=t,this.nextIFDByteOffset=i}}class re extends Error{constructor(e){super(`No image at index ${e}`),this.index=e}}class cr{async readRasters(e={}){const{window:t,width:i,height:n}=e;let{resX:s,resY:a,bbox:o}=e;const l=await this.getImage();let c=l;const f=await this.getImageCount(),h=l.getBoundingBox();if(t&&o)throw new Error('Both "bbox" and "window" passed.');if(i||n){if(t){const[g,x]=l.getOrigin(),[y,m]=l.getResolution();o=[g+t[0]*y,x+t[1]*m,g+t[2]*y,x+t[3]*m]}const u=o||h;if(i){if(s)throw new Error("Both width and resX passed");s=(u[2]-u[0])/i}if(n){if(a)throw new Error("Both width and resY passed");a=(u[3]-u[1])/n}}if(s||a){const u=[];for(let g=0;g<f;++g){const x=await this.getImage(g),{SubfileType:y,NewSubfileType:m}=x.fileDirectory;(g===0||y===2||m&1)&&u.push(x)}u.sort((g,x)=>g.getWidth()-x.getWidth());for(let g=0;g<u.length;++g){const x=u[g],y=(h[2]-h[0])/x.getWidth(),m=(h[3]-h[1])/x.getHeight();if(c=x,s&&s>y||a&&a>m)break}}let d=t;if(o){const[u,g]=l.getOrigin(),[x,y]=c.getResolution(l);d=[Math.round((o[0]-u)/x),Math.round((o[1]-g)/y),Math.round((o[2]-u)/x),Math.round((o[3]-g)/y)],d=[Math.min(d[0],d[2]),Math.min(d[1],d[3]),Math.max(d[0],d[2]),Math.max(d[1],d[3])]}return c.readRasters({...e,window:d})}}class xe extends cr{constructor(e,t,i,n,s={}){super(),this.source=e,this.littleEndian=t,this.bigTiff=i,this.firstIFDOffset=n,this.cache=s.cache||!1,this.ifdRequests=[],this.ghostValues=null}async getSlice(e,t){const i=this.bigTiff?4048:1024;return new er((await this.source.fetch([{offset:e,length:typeof t<"u"?t:i}]))[0],e,this.littleEndian,this.bigTiff)}async parseFileDirectoryAt(e){const t=this.bigTiff?20:12,i=this.bigTiff?8:2;let n=await this.getSlice(e);const s=this.bigTiff?n.readUint64(e):n.readUint16(e),a=s*t+(this.bigTiff?16:6);n.covers(e,a)||(n=await this.getSlice(e,a));const o={};let l=e+(this.bigTiff?8:2);for(let h=0;h<s;l+=t,++h){const d=n.readUint16(l),u=n.readUint16(l+2),g=this.bigTiff?n.readUint64(l+4):n.readUint32(l+4);let x,y;const m=ce(u),p=l+(this.bigTiff?12:8);if(m*g<=(this.bigTiff?8:4))x=C(n,u,g,p);else{const T=n.readOffset(p),A=ce(u)*g;if(n.covers(T,A))x=C(n,u,g,T);else{const I=await this.getSlice(T,A);x=C(I,u,g,T)}}g===1&&Pt.indexOf(d)===-1&&!(u===w.RATIONAL||u===w.SRATIONAL)?y=x[0]:y=x,o[k[d]]=y}const c=ar(o),f=n.readOffset(e+i+t*s);return new lr(o,c,f)}async requestIFD(e){if(this.ifdRequests[e])return this.ifdRequests[e];if(e===0)return this.ifdRequests[e]=this.parseFileDirectoryAt(this.firstIFDOffset),this.ifdRequests[e];if(!this.ifdRequests[e-1])try{this.ifdRequests[e-1]=this.requestIFD(e-1)}catch(t){throw t instanceof re?new re(e):t}return this.ifdRequests[e]=(async()=>{const t=await this.ifdRequests[e-1];if(t.nextIFDByteOffset===0)throw new re(e);return this.parseFileDirectoryAt(t.nextIFDByteOffset)})(),this.ifdRequests[e]}async getImage(e=0){const t=await this.requestIFD(e);return new Qt(t.fileDirectory,t.geoKeyDirectory,this.dataView,this.littleEndian,this.cache,this.source)}async getImageCount(){let e=0,t=!0;for(;t;)try{await this.requestIFD(e),++e}catch(i){if(i instanceof re)t=!1;else throw i}return e}async getGhostValues(){const e=this.bigTiff?16:8;if(this.ghostValues)return this.ghostValues;const t="GDAL_STRUCTURAL_METADATA_SIZE=",i=t.length+100;let n=await this.getSlice(e,i);if(t===C(n,w.ASCII,t.length,e)){const a=C(n,w.ASCII,i,e).split(`
`)[0],o=Number(a.split("=")[1].split(" ")[0])+a.length;o>i&&(n=await this.getSlice(e,o));const l=C(n,w.ASCII,o,e);this.ghostValues={},l.split(`
`).filter(c=>c.length>0).map(c=>c.split("=")).forEach(([c,f])=>{this.ghostValues[c]=f})}return this.ghostValues}static async fromSource(e,t,i){const n=(await e.fetch([{offset:0,length:1024}],i))[0],s=new Wt(n),a=s.getUint16(0,0);let o;if(a===18761)o=!0;else if(a===19789)o=!1;else throw new TypeError("Invalid byte order value.");const l=s.getUint16(2,o);let c;if(l===42)c=!1;else if(l===43){if(c=!0,s.getUint16(4,o)!==8)throw new Error("Unsupported offset byte-size.")}else throw new TypeError("Invalid magic number.");const f=c?s.getUint64(8,o):s.getUint32(4,o);return new xe(e,o,c,f,t)}close(){return typeof this.source.close=="function"?this.source.close():!1}}async function Sr(r,e){return xe.fromSource(nr(r),e)}export{Ir as B,Tr as L,Ar as a,Sr as f,ve as g};
